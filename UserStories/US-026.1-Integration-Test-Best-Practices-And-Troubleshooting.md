# US-026.1: Integration Test Best Practices and Troubleshooting Guide

**Parent Story**: US-026 - Setup Integration Test Project  
**Purpose**: Document lessons learned and best practices for integration testing with Entity Framework, in-memory databases, and test isolation

---

## Overview

This document provides guidelines for avoiding common pitfalls when setting up integration tests, particularly around database cleanup, test isolation, and Entity Framework tracking issues.

---

## Common Issues and Solutions

### 1. Database Cleanup Problems

#### Issue: Data Persisting Between Test Runs
**Symptoms:**
- Tests fail with "duplicate key" errors
- Count assertions fail (expecting X but finding 2X or more)
- Tests pass individually but fail when run together
- `SaveChangesAsync()` returns more entities than expected

**Root Causes:**
- `DatabaseCleaner` not properly removing all entities
- Multiple `SaveChanges()` calls causing inconsistent state
- Cleanup order not respecting foreign key constraints
- In-memory database not being reset between tests

**Solutions:**
1. **Consolidate Save Operations**: Only call `SaveChangesAsync()` once at the end of cleanup
   ```
   - Remove entities from all tables
   - THEN call SaveChangesAsync() once
   - NOT: Remove + Save for each table
   ```

2. **Respect Dependency Order**: Clean tables in correct order
   ```
   Order: UserRefreshTokens → Users → Roles → Companies → Categories → Organizations
   (Child entities first, parent entities last)
   ```

3. **Verify Cleanup Success**: Add validation after cleanup
   ```
   - Count remaining entities across all tables
   - Throw exception if cleanup incomplete
   - Log detailed information about remaining entities
   ```

4. **Use Verification Pattern**:
   ```
   After cleanup:
   - Verify Companies.Count == 0
   - Verify Users.Count == 0
   - Verify all critical tables empty
   ```

---

### 2. Entity Framework Change Tracking Issues

#### Issue: SaveChanges Returns Unexpected Count
**Symptoms:**
- Test adds 100 entities, `SaveChangesAsync()` returns 200
- Entities appear to be duplicated
- Previous test's data appears in current test

**Root Causes:**
- Entity Framework `ChangeTracker` retaining entities from previous operations
- Test data seeder adding entities that aren't cleaned up
- DbContext instance being reused across tests
- Entities in different states (Added, Modified, Deleted) all counted

**Solutions:**
1. **Detach Entities After Operations**:
   ```
   Option A: Clear ChangeTracker
   _context.ChangeTracker.Clear();
   
   Option B: Use fresh DbContext per test
   Create new DbContext instance for each test operation
   ```

2. **Adjust Assertions**:
   ```
   Instead of: result.Should().Be(100)
   Use: result.Should().BeGreaterThanOrEqualTo(100)
   
   Then verify the actual entities:
   var bulkCount = await _context.Companies
       .CountAsync(c => c.CompanyName.StartsWith("Bulk"));
   bulkCount.Should().Be(100);
   ```

3. **Track Initial State**:
   ```
   var initialCount = await _context.Companies.CountAsync();
   // ... add entities ...
   var finalCount = await _context.Companies.CountAsync();
   finalCount.Should().Be(initialCount + expectedNewCount);
   ```

---

### 3. Test Isolation Problems

#### Issue: Tests Interfere with Each Other
**Symptoms:**
- Tests pass individually but fail when run together
- Test order affects results
- Shared state between tests

**Root Causes:**
- In-memory database shared across test instances
- Static variables or singletons holding state
- Test fixtures not properly isolated
- Database not cleaned between tests

**Solutions:**
1. **Use Proper xUnit Patterns**:
   ```
   - IClassFixture<T>: Share context across tests in a class
   - ICollectionFixture<T>: Share context across test classes
   - IAsyncLifetime: Initialize/cleanup per test
   ```

2. **Implement Proper Lifecycle**:
   ```
   InitializeAsync():
   - Clean database
   - Seed required data
   - Reset any shared state
   
   DisposeAsync():
   - Clean database again
   - Dispose resources
   - Verify cleanup
   ```

3. **Use Unique Database Names**:
   ```
   Option A: GUID-based database names
   UseInMemoryDatabase($"TestDb_{Guid.NewGuid()}")
   
   Option B: Test-specific names
   UseInMemoryDatabase($"TestDb_{testClassName}_{testMethodName}")
   ```

4. **Avoid Static State**:
   ```
   - Don't use static DbContext
   - Don't use static service instances
   - Don't cache data in static variables
   ```

---

### 4. In-Memory Database Limitations

#### Issue: Relational Features Not Supported
**Symptoms:**
- "Relational-specific methods can only be used when the context is using a relational database provider"
- Migration errors in tests
- Transaction not supported errors
- Raw SQL queries fail

**Root Causes:**
- In-memory database doesn't support migrations
- In-memory database doesn't support transactions
- In-memory database doesn't support stored procedures
- Application code trying to run migrations at startup

**Solutions:**
1. **Skip Migrations in Test Environment**:
   ```
   In Program.cs or Startup:
   if (!app.Environment.IsEnvironment("Test"))
   {
       dbContext.Database.Migrate();
   }
   ```

2. **Skip Relational Tests**:
   ```
   [Fact(Skip = "Skipped for in-memory database - migrations not supported")]
   public async Task Database_ShouldApplyMigrations() { }
   
   [Fact(Skip = "Skipped for in-memory database - transactions not supported")]
   public async Task Transaction_ShouldRollback() { }
   ```

3. **Use Alternative Test Approaches**:
   ```
   Instead of testing migrations:
   - Test EnsureCreated() works
   - Test schema can be created
   - Test all DbSets are accessible
   
   Instead of testing transactions:
   - Test SaveChanges() behavior
   - Test rollback through DbContext disposal
   - Use integration tests with real database for transaction tests
   ```

4. **Consider Real Database for Complex Tests**:
   ```
   For tests requiring:
   - Migrations
   - Transactions
   - Stored procedures
   - Complex queries
   
   Use:
   - Testcontainers (Docker-based real database)
   - LocalDB (SQL Server)
   - SQLite (with limitations)
   ```

---

### 5. Identity Framework Challenges

#### Issue: User/Role Creation Failing
**Symptoms:**
- "Required properties '{'PhoneNumber'}' are missing"
- "User already in role" errors
- Identity tables not accessible in cleanup

**Root Causes:**
- Identity framework has special requirements for entities
- Identity manages its own tables (AspNetUsers, AspNetRoles, etc.)
- Properties inherited from IdentityUser have validation rules
- In-memory database doesn't perfectly match SQL Server behavior

**Solutions:**
1. **Ensure All Required Properties Set**:
   ```
   User must have:
   - UserName
   - Email
   - NormalizedUserName
   - NormalizedEmail
   - SecurityStamp
   - ConcurrencyStamp
   - PhoneNumber (if overridden as required)
   ```

2. **Use UserManager/RoleManager**:
   ```
   Don't: _context.Users.Add(user)
   Do: await _userManager.CreateAsync(user, password)
   
   Don't: _context.Roles.Add(role)
   Do: await _roleManager.CreateAsync(role)
   ```

3. **Handle Role Assignment Carefully**:
   ```
   Before assigning:
   - Check if user already has role
   - Check if role exists
   - Handle errors appropriately
   
   var userRoles = await _userManager.GetRolesAsync(user);
   if (!userRoles.Contains(roleName))
   {
       await _userManager.AddToRoleAsync(user, roleName);
   }
   ```

4. **Clean Identity Tables Properly**:
   ```
   Order matters:
   1. UserRefreshTokens (custom table)
   2. AspNetUserTokens
   3. AspNetUserLogins
   4. AspNetUserClaims
   5. AspNetUserRoles (junction table)
   6. AspNetRoleClaims
   7. Users (AspNetUsers)
   8. Roles (AspNetRoles)
   ```

---

### 6. Test Data Management

#### Issue: Inconsistent Test Data
**Symptoms:**
- Tests sometimes pass, sometimes fail
- Tests depend on execution order
- Seed data conflicts with test data

**Root Causes:**
- Test data seeder runs before cleanup verification
- Seeder doesn't check for existing data properly
- Test-specific data conflicts with seed data

**Solutions:**
1. **Smart Seeding**:
   ```
   public async Task SeedCompaniesAsync()
   {
       // Always check before seeding
       if (await _context.Companies.AnyAsync())
           return;
       
       // Use unique, identifiable names
       var companies = new List<Company>
       {
           CreateCompany("Seed_Company_1"),
           CreateCompany("Seed_Company_2"),
       };
   }
   ```

2. **Separate Seed Data from Test Data**:
   ```
   Seed Data: Minimal data required for all tests
   - 1-2 Users
   - 1-2 Roles
   - 1-2 Organizations
   
   Test Data: Specific data for each test
   - Use unique prefixes: "Test_", "Bulk_", "Integration_"
   - Create in test method, not in seeder
   ```

3. **Use Test Data Builders**:
   ```
   public static class TestDataFactory
   {
       public static User CreateUser(string prefix = "Test")
       {
           return new User
           {
               UserName = $"{prefix}_User_{Guid.NewGuid()}",
               // ... other properties
           };
       }
   }
   ```

---

### 7. Performance Considerations

#### Issue: Tests Running Slowly
**Symptoms:**
- Integration tests take several minutes
- Individual tests take > 1 second
- Database operations are slow

**Root Causes:**
- Creating new DbContext/WebApplicationFactory for each test
- Not reusing test infrastructure
- Excessive data seeding
- Not using in-memory database efficiently

**Solutions:**
1. **Reuse Infrastructure**:
   ```
   Use IClassFixture to share:
   - WebApplicationFactory
   - Database connections
   - Configuration
   
   But still ensure proper cleanup!
   ```

2. **Minimize Seeding**:
   ```
   Only seed:
   - Data required by ALL tests
   - Minimal set of master data
   
   Don't seed:
   - Test-specific data
   - Large datasets
   - Optional reference data
   ```

3. **Use Parallel Execution**:
   ```
   xUnit runs tests in parallel by default
   
   To disable for specific tests:
   [Collection("Sequential")]
   public class MyIntegrationTests { }
   ```

4. **Optimize Cleanup**:
   ```
   Instead of: Delete all, then verify each table
   Use: Delete all, then verify once
   
   Consider: Using transactions that rollback
   (if using real database)
   ```

---

### 8. Authentication and API Configuration Issues

#### Issue: 401 Unauthorized Errors in Integration Tests
**Symptoms:**
- Tests fail with "Response status code does not indicate success: 401 (Unauthorized)"
- Authentication endpoint returns 401 when trying to get JWT token
- All authenticated API endpoints fail with 401
- Tests that don't require authentication (like health checks) work fine

**Root Causes:**
- JWT authentication not properly configured in test environment
- UserManager/SignInManager not finding users in in-memory database
- Password hashing differences between test and production
- Identity framework not properly initialized in test context
- Auth middleware not configured in WebApplicationFactory
- Missing authentication services in test DI container
- Different database instance for authentication vs. data operations

**Solutions:**

1. **Verify Identity Services Registration**:
   ```
   In IntegrationTestWebApplicationFactory:
   - Ensure Identity services are registered
   - Configure UserManager and SignInManager
   - Set up password hashing options
   - Register authentication middleware
   
   Check that:
   - AddIdentity<User, Role>() is called
   - AddEntityFrameworkStores<ApplicationDbContext>() is included
   - JWT authentication is configured with correct settings
   ```

2. **Ensure Same DbContext for All Operations**:
   ```
   Problem: Different scopes might have different DbContext instances
   
   Solution:
   - Use service provider from Factory.Services
   - Create scopes consistently
   - Ensure TestDataSeeder uses same DbContext as API
   - Verify database name is consistent across all services
   ```

3. **Password Hashing in Tests**:
   ```
   Issue: UserManager.CreateAsync hashes passwords
         But direct User creation doesn't
   
   Solutions:
   Option A: Always use UserManager.CreateAsync in seeder
   - await _userManager.CreateAsync(user, "TestPassword123!")
   - This properly hashes passwords
   
   Option B: Use PasswordHasher manually
   - var hasher = new PasswordHasher<User>();
   - user.PasswordHash = hasher.HashPassword(user, "TestPassword123!");
   
   Don't: Set PasswordHash to plain text
   ```

4. **Authentication Endpoint Configuration**:
   ```
   Common issues:
   - Auth endpoint not implemented (/api/auth/login)
   - Auth endpoint requires different request format
   - Auth endpoint route doesn't match test expectations
   
   Solutions:
   - Verify auth endpoint exists and is accessible
   - Check request/response format matches test expectations
   - Use actual login endpoint from your API
   - Mock authentication if real endpoint unavailable
   ```

5. **JWT Configuration in Tests**:
   ```
   Ensure JWT settings match between:
   - appsettings.Test.json
   - In-memory configuration
   - API startup configuration
   
   Required settings:
   - Secret (must be long enough, typically 256+ bits)
   - Issuer
   - Audience
   - ExpiryMinutes
   
   Common mistake: Using different JWT settings in test vs. API
   ```

6. **WebApplicationFactory Authentication Setup**:
   ```
   In ConfigureWebHost:
   
   Option A: Use Real Authentication
   - Configure same auth as production
   - Ensure all auth services registered
   - Use real JWT token generation
   
   Option B: Mock Authentication
   - Use TestAuthHandler
   - Bypass authentication for tests
   - Set claims programmatically
   
   Recommendation: Use real authentication for integration tests
   ```

7. **Debug Authentication Flow**:
   ```
   Step-by-step debugging:
   
   1. Verify users exist in database:
      var users = await context.Users.ToListAsync();
      // Should see seeded users
   
   2. Check user can be found:
      var user = await userManager.FindByNameAsync("testuser1");
      // Should not be null
   
   3. Verify password is hashed:
      user.PasswordHash.Should().NotBeNullOrEmpty();
      // Should be a hashed value, not plain text
   
   4. Test password verification:
      var result = await signInManager.CheckPasswordSignInAsync(
          user, "TestPassword123!", false);
      // Should succeed
   
   5. Check JWT token generation:
      // Verify token is generated correctly
      // Verify token contains correct claims
   ```

8. **Alternative Approaches**:
   ```
   If authentication continues to fail:
   
   Option A: Bypass Authentication for Tests
   - Create TestAuthHandler that always succeeds
   - Register in test DI container
   - Set claims based on test requirements
   
   Option B: Use In-Memory Authentication
   - Don't use real Identity framework
   - Mock authentication service
   - Return fake tokens
   
   Option C: Separate Auth Tests from API Tests
   - Test authentication separately
   - Use pre-generated tokens for API tests
   - Focus on API behavior, not auth flow
   ```

9. **Common Pitfalls**:
   ```
   ❌ Don't: Create users directly in database without password hash
   ✅ Do: Use UserManager.CreateAsync with password
   
   ❌ Don't: Assume seeded users are immediately available
   ✅ Do: Verify users exist before trying to authenticate
   
   ❌ Don't: Use different database names for different services
   ✅ Do: Ensure all services use same in-memory database
   
   ❌ Don't: Skip Identity middleware registration
   ✅ Do: Register all Identity services in test setup
   
   ❌ Don't: Use production auth endpoints without proper setup
   ✅ Do: Either fully configure auth or mock it consistently
   ```

10. **Verification Checklist**:
    ```
    Before running authenticated tests:
    
    Database Setup:
    ☐ Users are seeded correctly
    ☐ Passwords are hashed properly
    ☐ Roles are assigned to users
    ☐ Same database instance used everywhere
    
    Identity Configuration:
    ☐ Identity services registered
    ☐ UserManager available in DI container
    ☐ SignInManager configured correctly
    ☐ Password validation rules match seeded passwords
    
    JWT Configuration:
    ☐ JWT settings configured in test environment
    ☐ Secret key is long enough
    ☐ Issuer and Audience match
    ☐ Token expiry is reasonable for tests
    
    API Configuration:
    ☐ Authentication endpoint exists
    ☐ Auth middleware is registered
    ☐ Request/response format matches expectations
    ☐ CORS configured if needed
    
    Test Environment:
    ☐ Environment set to "Test"
    ☐ Test-specific configuration loaded
    ☐ All services properly scoped
    ```

**Recommended Solution Path:**

1. **First, verify the basics**:
   - Check users exist in database after seeding
   - Verify passwords are hashed
   - Confirm authentication endpoint is accessible

2. **Then, fix the authentication flow**:
   - Ensure UserManager/SignInManager work correctly
   - Verify JWT token generation
   - Test token validation

3. **Finally, integrate with tests**:
   - Use proper authentication in test base class
   - Handle token refresh if needed
   - Create helper methods for common auth scenarios

**Example Implementation Strategy:**

```
Phase 1: Diagnose
- Add logging to see where authentication fails
- Check database state after seeding
- Verify Identity services are registered

Phase 2: Fix Seeding
- Use UserManager for all user creation
- Ensure passwords are hashed
- Verify users can be retrieved

Phase 3: Fix Authentication
- Implement or fix /api/auth/login endpoint
- Ensure JWT token generation works
- Verify token contains correct claims

Phase 4: Integrate with Tests
- Update BaseIntegrationTest to handle auth properly
- Create helper methods for authenticated requests
- Add error handling for auth failures
```

---

## Best Practices Summary

### DO's ✅

1. **Test Isolation**:
   - Clean database before AND after each test
   - Use unique identifiers for test data
   - Verify cleanup success

2. **Entity Framework**:
   - Track initial entity counts
   - Clear ChangeTracker when needed
   - Use proper assertion patterns

3. **Database Management**:
   - Respect foreign key constraints in cleanup
   - Consolidate SaveChanges() calls
   - Use appropriate database provider for test type

4. **Test Organization**:
   - Use BaseIntegrationTest for common functionality
   - Implement IAsyncLifetime properly
   - Group related tests in collections

5. **Identity Framework**:
   - Use UserManager/RoleManager for user operations
   - Set all required properties
   - Handle role assignments gracefully

6. **Authentication**:
   - Always hash passwords when creating users
   - Use UserManager.CreateAsync for user creation
   - Verify authentication endpoint is accessible
   - Ensure JWT configuration is consistent
   - Test authentication flow separately when needed

### DON'Ts ❌

1. **Test Isolation**:
   - Don't share DbContext across tests
   - Don't use static state
   - Don't depend on test execution order

2. **Entity Framework**:
   - Don't assume SaveChanges() count equals added entities
   - Don't forget to save changes after cleanup
   - Don't mix in-memory and relational features

3. **Database Management**:
   - Don't delete parent entities before children
   - Don't call SaveChanges() multiple times in cleanup
   - Don't skip cleanup verification

4. **Test Organization**:
   - Don't put test-specific logic in shared fixtures
   - Don't seed large amounts of unnecessary data
   - Don't ignore test warnings

5. **Environment Configuration**:
   - Don't run migrations for in-memory databases
   - Don't use relational features in in-memory tests
   - Don't forget to set environment to "Test"

6. **Authentication**:
   - Don't create users without hashing passwords
   - Don't assume authentication works without testing it
   - Don't use plain text passwords in PasswordHash field
   - Don't skip Identity service registration in tests
   - Don't use different JWT settings between test and API
   - Don't ignore 401 errors - they indicate auth misconfiguration

---

## Troubleshooting Checklist

When integration tests fail, check these items:

### Database Issues
- [ ] Is the database being cleaned before the test?
- [ ] Is the cleanup respecting foreign key constraints?
- [ ] Is SaveChanges() being called after cleanup?
- [ ] Are there any entities left after cleanup?

### Entity Tracking Issues
- [ ] Is the ChangeTracker accumulating entities?
- [ ] Are assertions accounting for tracked entities?
- [ ] Is the DbContext being reused inappropriately?

### Test Isolation Issues
- [ ] Can the test run independently?
- [ ] Does the test affect other tests?
- [ ] Is the test using shared state?
- [ ] Is the database name unique per test?

### Environment Issues
- [ ] Is the environment set to "Test"?
- [ ] Are migrations being skipped?
- [ ] Is the correct database provider being used?

### Identity Issues
- [ ] Are all required properties set?
- [ ] Is UserManager being used for user operations?
- [ ] Are role assignments handled properly?

### Performance Issues
- [ ] Is infrastructure being reused appropriately?
- [ ] Is excessive data being seeded?
- [ ] Are tests running in parallel appropriately?

### Authentication Issues
- [ ] Are users seeded with properly hashed passwords?
- [ ] Is UserManager being used for user creation?
- [ ] Does the authentication endpoint exist and work?
- [ ] Are JWT settings configured correctly?
- [ ] Is Identity middleware registered in test setup?
- [ ] Can users be found by UserManager?
- [ ] Do password verification attempts succeed?

---

## Recommended Test Structure

```
BackendWebService.IntegrationTests/
├── Base/
│   └── BaseIntegrationTest.cs           # Common test infrastructure
├── Infrastructure/
│   ├── IntegrationTestWebApplicationFactory.cs
│   ├── ITestDataSeeder.cs
│   ├── TestDataSeeder.cs
│   ├── IDatabaseCleaner.cs
│   ├── DatabaseCleaner.cs               # Proper cleanup logic
│   ├── ITestEnvironment.cs
│   └── TestEnvironment.cs
├── Utilities/
│   ├── TestDataFactory.cs               # Test data builders
│   └── TestConfigurationHelper.cs       # Configuration utilities
├── Database/
│   └── DatabaseIntegrationTests.cs      # Database-specific tests
├── API/
│   └── ApiEndToEndTests.cs              # API endpoint tests
├── ExternalServices/
│   └── ExternalServiceIntegrationTests.cs
└── SampleTests/
    └── IntegrationTestSetupValidationTests.cs
```

---

## Future Improvements

### Consider Implementing

1. **Database Snapshots**:
   - Save clean database state
   - Restore snapshot instead of cleanup
   - Faster test execution

2. **Test Containers**:
   - Use real SQL Server in Docker
   - Full SQL Server features available
   - More realistic testing

3. **Parallel Database Instances**:
   - Each test class gets own database
   - True isolation
   - Better performance

4. **Smart Cleanup**:
   - Only clean tables that were modified
   - Track which tests use which tables
   - Faster cleanup

5. **Test Data Versioning**:
   - Version test data schemas
   - Detect breaking changes
   - Maintain backwards compatibility

---

## References and Resources

### xUnit
- [xUnit Documentation](https://xunit.net/)
- [Shared Context](https://xunit.net/docs/shared-context)
- [IAsyncLifetime](https://xunit.net/docs/shared-context#async-lifetime)

### Entity Framework
- [EF Core Testing](https://learn.microsoft.com/en-us/ef/core/testing/)
- [In-Memory Database Provider](https://learn.microsoft.com/en-us/ef/core/testing/testing-with-the-inmemory)
- [Testing with SQLite](https://learn.microsoft.com/en-us/ef/core/testing/testing-with-sqlite)

### ASP.NET Core Testing
- [Integration Testing](https://learn.microsoft.com/en-us/aspnet/core/test/integration-tests)
- [WebApplicationFactory](https://learn.microsoft.com/en-us/aspnet/core/test/integration-tests#basic-tests-with-the-default-webapplicationfactory)

### Testcontainers
- [Testcontainers for .NET](https://dotnet.testcontainers.org/)
- [SQL Server Module](https://dotnet.testcontainers.org/modules/mssql/)

---

## Conclusion

Integration testing with Entity Framework and in-memory databases requires careful attention to:
- **Database cleanup and test isolation**
- **Entity Framework change tracking**
- **Identity framework requirements**
- **In-memory database limitations**
- **Authentication and JWT configuration**
- **Password hashing and user management**

By following the guidelines in this document, you can avoid common pitfalls and create reliable, maintainable integration tests.

### Key Takeaways

1. **Database Issues (SOLVED)**:
   - Clear ChangeTracker before and after operations
   - Consolidate SaveChanges calls
   - Use unique database names per test class

2. **Authentication Issues (COMMON)**:
   - Always use UserManager for user creation
   - Hash passwords properly
   - Verify authentication endpoint exists
   - Configure JWT settings consistently
   - Test auth flow separately first

3. **Test Isolation (CRITICAL)**:
   - Each test should be independent
   - Clean database before and after tests
   - Avoid shared state

4. **Performance (IMPORTANT)**:
   - Reuse infrastructure where appropriate
   - Minimize data seeding
   - Use parallel execution when safe

---

**Last Updated**: Based on issues encountered during US-026 implementation (Database cleanup + Authentication)  
**Status**: Active Guidelines  
**Next Review**: After US-027, US-028, US-029 completion  
**Version**: 2.0 (Added Section 8: Authentication Issues)

